# 테스트 코드
+ TDD는 테스트가 주도하는 개발을 이야기 하며 테스트 코드를 먼저 작성하는것부터 시작
![image](https://user-images.githubusercontent.com/76415175/123739782-2f238e80-d8e2-11eb-9be2-09e5883e02b2.png)
+ 항상 실패하는 테스트를 먼저 작성하고(Red)
+ 테스트가 통과하는 프로덕션 코드를 작성하고(Green)
+ 테스트가 통과하면 프로덕션 코드를 리팩토링한다(Refactor)

### 단위테스트
+ TDD의 첫번째 단계인 기능 단위의 테스트 코드를 작성하는것
+ TDD와 달리 테스트 코드를 먼저 작성해야하는 것도 아니고 리팩토링도 포함되지 않는 순수하게 테스트 코드 작성을 의미

### Application
```java
//앞으로 만들 프로젝트의 메인 클래스
@SpringBootApplication//스프링 부트의 자동 설정,스프링 Bean읽기와 생성을 모두 자동을 설정
public class Application {
    public static void main(String[] args) {
        //SpringApplication.run으로 내장 WAS를 실행(내부)
        SpringApplication.run(Application.class,args);
    }
}
```
### HelloController
```java
@RestController//컨트롤러를 JSON으로 반환하는 컨트롤러로 만들어줌
public class HelloController {

    @GetMapping("/hello")//HTTP Method인 Get요청을 받을때 사용
    public String hello() {
        return "hello";
    }
}
```
+ @RestController
    + 컨트롤러를 JSON으로 반환하는 컨트롤러로 만들어줌
    + 예전에는 @ResponseBody를 각 메소드마다 선언했던 것을 한번에 사용할수 있게 해준다
+ @GetMapping
    + HTTP Method인 Get요청을 받을때 사용
    + 예전에는 @RequestMapping(method=RequestMethod.GET)로 사용됨
    + /hello로 요청이 오면 문자열 hello를 반환하는 기능

### HelloControllerTest
```java
//테스트 진행시 JUnit에 내장된 실행자 외에 다른 실행자를 실행 SpringRunner라는 스프링 실행자를 사용
@RunWith(SpringRunner.class)
//Web(Spring Mvc)에 집중할수 있는 어노테이션, 컨트롤러를 사용하기 위해 사용
@WebMvcTest(controllers = HelloController.class)
public class HelloControllerTest {
    //스프링이 관리하는 빈을 주입
    @Autowired
    //웹API를 테스트할때 사용,HTTP에 대한 API테스트 가능
    private MockMvc mvc;

    @Test
    public void hello가_리턴된다() throws  Exception {
        String hello = "hello";

        mvc.perform(get("/hello"))//HTTP Get요청
                .andExpect(status().isOk())//HTTP header의 Status를 검증 200인지를 검증
                .andExpect(content().string(hello));//응답 본문의 내용을 검증,Controller에서 hello를 리턴하기에 값이 맞는지 검증
    }
}
```
+ @RunWith(SpringRunner.class)
    + 테스트 진행시 JUnit에 내장된 실행자 외에 다른 실행자를 실행 SpringRunner라는 스프링 실행자를 사용
    + 스프링부트 테스트와 JUnit 사이에 연결자 역할
+ @WebMvcTest
    + 여러 어노테이션중, Web(Spring Mvc)에 집중할수 있는 어노테이션
    + 선언시 @Controller,@ControllerAdvice 등을 사용할수 있음
    + 단 @Service,@Component,@Repository 등은 사용할수 없음
    + 컨트롤러만 사용하기 때문에 사용
+ @Autowired
    + 스프링이 관리하는 빈을 주입
+ private MockMvc mvc
    + 웹API를 테스트할때 사용,HTTP(GET,POST)에 대한 API테스트 가능
    + 스프링 MVC 테스트의 시작점
+ mvc.perform(get("/hello"))
    + MockMvc를 통해 /hello 주소로 GET요청을 한다
    + 체이닝이 지원되어 여러 검증 기능을 이어서 선언할수 있다
+ andExpect(status().isOk())
    + mvc.perform의 결과를 검증
    + HTTP header의 Status를 검증 200인지를 검증
+ andExpect(content().string(hello))
    + mvc.perform의 결과를 검증
    + 응답 본문의 내용을 검증,Controller에서 hello를 리턴하기에 값이 맞는지 검증
### 프로젝트 실행 결과
![image](https://user-images.githubusercontent.com/76415175/123741106-70b53900-d8e4-11eb-99c3-8f584a3787ca.png)

### Lombok설치
+ 자바 개발자들의 필수 라이브러리로 Getter,Setter,기본생성자,toString등을 어노테이션으로 자동생성할수 있게 해준다
1. build.gradle에 라이브러리를 내려받는다
```gradle
compile('org.projectlombok:lombok')//lombok
```
2. plugins에서 lombok을 설치한다
![lombok1](https://user-images.githubusercontent.com/76415175/123741920-d655f500-d8e5-11eb-90d8-01d85cb4192e.PNG)
3. 설치후 인텔리제이를 재시작후 settings->Build->Compiler->Annotation Processors에서 Enable annotation processing을 체크한다
![lombok2](https://user-images.githubusercontent.com/76415175/123741926-d7872200-d8e5-11eb-94fe-f82c7d465ac7.PNG)
+ lombok은 프로젝트 마다 설정해야하기에 플러그인은 한번 설치를 하면 되지만 build.gradle에 라이브러리 추가와 Enable annotation processing을 체크하는 것은 프로젝트 마다 진행해야한다

### Lombok으로 리팩토링